pipeline {
    agent any
    
    environment {
        AWS_REGION = 'us-east-1'
        ECR_REPOSITORY = '${AWS_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/jenkins-cicd-dev'
        ECS_CLUSTER = 'jenkins-cicd-dev'
        ECS_SERVICE = 'jenkins-cicd-dev'
        DOCKER_IMAGE = 'sample-app'
        DOCKER_TAG = "${BUILD_NUMBER}"
        GITHUB_REPO = 'https://github.com/ndevops25/jenkins-cicd-aws.git'
        GITHUB_CREDENTIALS = 'github-credentials'  // ID das credenciais no Jenkins
        APP_PORT = '5001'
        APP_VERSION = "${BUILD_NUMBER}"
    }
    
    stages {
        stage('Checkout') {
            steps {
                git branch: 'main',
                    credentialsId: GITHUB_CREDENTIALS,
                    url: GITHUB_REPO
            }
        }
        
        stage('Test Python') {
            steps {
                dir('sample-app') {
                    sh '''
                    python3 -m venv venv
                    . venv/bin/activate
                    pip install -r requirements.txt
                    pytest test_app.py -v
                    '''
                }
            }
        }
        
        stage('Build Docker Image') {
            steps {
                dir('sample-app') {
                    sh '''
                    docker build -t ${DOCKER_IMAGE}:${DOCKER_TAG} \
                        --build-arg PORT=${APP_PORT} \
                        --build-arg VERSION=${APP_VERSION} .
                    '''
                }
            }
        }
        
        stage('Test Container') {
            steps {
                script {
                    sh '''
                    docker run -d --name test-container \
                        -p ${APP_PORT}:${APP_PORT} \
                        -e PORT=${APP_PORT} \
                        -e APP_VERSION=${APP_VERSION} \
                        ${DOCKER_IMAGE}:${DOCKER_TAG}
                    
                    sleep 5
                    
                    curl -f http://localhost:${APP_PORT}/health
                    
                    docker stop test-container
                    docker rm test-container
                    '''
                }
            }
        }

        stage('Get Infrastructure Info') {
            steps {
                script {
                    // Pegar informações do Terraform
                    def ecrUrl = sh(
                        script: "cd terraform && terraform output -raw ecr_repository_url",
                        returnStdout: true
                    ).trim()
                    
                    def ecsCluster = sh(
                        script: "cd terraform && terraform output -raw ecs_cluster_name",
                        returnStdout: true
                    ).trim()
                    
                    env.ECR_REPOSITORY = ecrUrl
                    env.ECS_CLUSTER = ecsCluster
                }
            }
        }
        
        stage('Push to ECR') {
            steps {
                script {
                    // Login no ECR
                    sh '''
                    aws ecr get-login-password --region ${AWS_REGION} | \
                    docker login --username AWS --password-stdin ${ECR_REPOSITORY}
                    '''
                    
                    // Tag e push da imagem
                    sh '''
                    docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${ECR_REPOSITORY}:${DOCKER_TAG}
                    docker tag ${DOCKER_IMAGE}:${DOCKER_TAG} ${ECR_REPOSITORY}:latest
                    
                    docker push ${ECR_REPOSITORY}:${DOCKER_TAG}
                    docker push ${ECR_REPOSITORY}:latest
                    '''
                }
            }
        }
        
        stage('Deploy to ECS') {
            when {
                branch 'main'
            }
            steps {
                script {
                    // Atualizar ECS Service para usar nova imagem
                    sh '''
                    aws ecs update-service \
                        --cluster ${ECS_CLUSTER} \
                        --service ${ECS_SERVICE} \
                        --force-new-deployment \
                        --region ${AWS_REGION}
                    '''
                    
                    // Aguardar deploy
                    sh '''
                    aws ecs wait services-stable \
                        --cluster ${ECS_CLUSTER} \
                        --services ${ECS_SERVICE} \
                        --region ${AWS_REGION}
                    '''
                }
            }
        }
    }
    
    post {
        always {
            cleanWs()
            sh 'docker image prune -f || true'
        }
        success {
            echo "Deploy realizado com sucesso!"
            echo "Versão ${APP_VERSION} implantada no ECS"
        }
        failure {
            echo 'Pipeline falhou!'
        }
    }
}